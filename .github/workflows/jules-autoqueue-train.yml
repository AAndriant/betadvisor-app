name: Jules — Autoqueue Train

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

# ─────────────────────────────────────────────────────────────
# CRITIQUE : cancel-in-progress DOIT être false
# On veut traiter TOUS les events, jamais en annuler un.
# ─────────────────────────────────────────────────────────────
concurrency:
  group: jules-train-queue
  cancel-in-progress: false

# ─────────────────────────────────────────────────────────────
# Permissions explicites requises (read-only par défaut sur
# workflow_run — Bug 3 v1 validé)
# ─────────────────────────────────────────────────────────────
permissions:
  contents: write        # requis pour repos.merge
  issues: write          # requis pour addLabels / removeLabel
  pull-requests: write   # requis pour pulls.list

jobs:
  autoqueue:
    # ⚠️ DOUBLE GUARD — pièce centrale du Night Train :
    # 1. CI doit être passée (success)
    # 2. La branche doit commencer par jules/
    # 3. La branche ne doit PAS être jules/train elle-même
    #    (évite la boucle infinie sur push train → CI → autoqueue)
    if: >-
      github.event.workflow_run.conclusion == 'success' &&
      startsWith(github.event.workflow_run.head_branch, 'jules/') &&
      github.event.workflow_run.head_branch != 'jules/train'

    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Autoqueue — merge, label, chain, invoke Jules
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}  # via env, pas input (appel fetch direct)
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const headBranch = context.payload.workflow_run.head_branch;
            console.log(`[autoqueue] Processing branch: ${headBranch}`);

            // ─── 1. Trouver la PR ───────────────────────────────────
            // ⚠️ NE PAS utiliser workflow_run.pull_requests (souvent vide)
            const { data: prs } = await github.rest.pulls.list({
              owner, repo,
              head: `${owner}:${headBranch}`,
              state: 'open',
            });

            if (prs.length === 0) {
              console.log(`[autoqueue] No open PR found for ${headBranch}. Skipping.`);
              return;
            }

            const pr = prs[0];
            console.log(`[autoqueue] Found PR #${pr.number}: ${pr.title}`);

            // ─── 2. Merge PR → jules/train ──────────────────────────
            try {
              await github.rest.repos.merge({
                owner, repo,
                base: 'jules/train',
                head: headBranch,
                commit_message: `[train] Merge ${headBranch} (PR #${pr.number})`,
              });
              console.log(`[autoqueue] Merged ${headBranch} → jules/train ✅`);
            } catch (mergeErr) {
              console.error(`[autoqueue] Merge failed: ${mergeErr.message}`);
              // Conflit → label needs:human et stop proprement
              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: pr.number,
                labels: ['needs:human'],
              });
              return;
            }

            // ─── 3. Extraire l'issue depuis le body de la PR ────────
            const body = pr.body || '';
            // Pattern: Closes #N, Fixes #N, Resolves #N (case-insensitive, optionnel `:`)
            const issueMatch = body.match(/(?:closes|fixes|resolves)\s*:?\s*#(\d+)/i);
            let issueNumber = null;

            if (issueMatch) {
              issueNumber = parseInt(issueMatch[1], 10);
            } else {
              // Fallback: [#N] dans le titre de la PR
              const titleMatch = pr.title.match(/\[#(\d+)\]/);
              if (titleMatch) issueNumber = parseInt(titleMatch[1], 10);
            }

            if (!issueNumber) {
              console.log('[autoqueue] Could not extract issue number from PR. Skipping chain.');
              return;
            }
            console.log(`[autoqueue] Linked issue: #${issueNumber}`);

            // ─── 4. Marquer l'issue courante ready ──────────────────
            try {
              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: issueNumber,
                labels: ['ready'],
              });
              try {
                await github.rest.issues.removeLabel({
                  owner, repo,
                  issue_number: issueNumber,
                  name: 'agent:jules',
                });
              } catch (e) { /* label déjà absent : OK */ }
            } catch (e) {
              console.log(`[autoqueue] Label update failed on #${issueNumber}: ${e.message}`);
            }

            // ─── 5. Trouver l'issue suivante bloquée ────────────────
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner, repo,
              state: 'open',
              labels: 'blocked',
              per_page: 100,
            });

            // Match: "Blocked by #N", "Depends on #N", "After #N"
            const blockedByRegex = new RegExp(
              `(?:blocked\\s+by|depends\\s+on|after)\\s*:?\\s*#${issueNumber}`,
              'i'
            );

            // ⚠️ Une issue peut avoir plusieurs "Blocked by #N"
            // On ne débloque que si TOUTES ses dépendances sont résolues (labels: ready)
            const candidates = allIssues.filter(issue => {
              return blockedByRegex.test(issue.body || '');
            });

            console.log(`[autoqueue] Found ${candidates.length} candidate(s) blocked by #${issueNumber}`);

            for (const candidate of candidates) {
              // Extraire toutes les dépendances "Blocked by #N" du body
              const allBlockedBy = [...(candidate.body || '').matchAll(
                /(?:blocked\s+by|depends\s+on|after)\s*:?\s*#(\d+)/gi
              )].map(m => parseInt(m[1], 10));

              console.log(`[autoqueue] Issue #${candidate.number} blocked by: ${allBlockedBy.join(', ')}`);

              // Vérifier que TOUTES les dépendances sont "ready"
              let allResolved = true;
              for (const depNum of allBlockedBy) {
                if (depNum === issueNumber) continue; // celle qu'on vient de finir
                try {
                  const { data: depIssue } = await github.rest.issues.get({
                    owner, repo,
                    issue_number: depNum,
                  });
                  const depLabels = depIssue.labels.map(l => l.name);
                  if (!depLabels.includes('ready')) {
                    console.log(`[autoqueue] Dep #${depNum} not yet ready. Skipping #${candidate.number}.`);
                    allResolved = false;
                    break;
                  }
                } catch (e) {
                  console.log(`[autoqueue] Could not fetch dep #${depNum}: ${e.message}`);
                  allResolved = false;
                  break;
                }
              }

              if (!allResolved) continue;

              const nextIssue = candidate;
              console.log(`[autoqueue] Unblocking issue #${nextIssue.number}: ${nextIssue.title}`);

              // ─── 6. Débloquer l'issue suivante (labels) ─────────
              try {
                await github.rest.issues.removeLabel({
                  owner, repo,
                  issue_number: nextIssue.number,
                  name: 'blocked',
                });
              } catch (e) { /* label absent : OK */ }

              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: nextIssue.number,
                labels: ['agent:jules'],
              });

              // ─── 7. Appel DIRECT à l'API Jules ──────────────────
              // ⚠️ CRITIQUE — Anti-récursion GitHub :
              // Les labels posés par GITHUB_TOKEN ne déclenchent PAS d'autres workflows.
              // On appelle donc l'API Jules directement (bypass validé v1 — Bug 5).
              const julesApiKey = process.env.JULES_API_KEY;
              if (!julesApiKey) {
                console.error('[autoqueue] JULES_API_KEY not set. Cannot invoke Jules API.');
                return;
              }

              const nextBody = nextIssue.body || '(no body)';
              const prompt = [
                `You are Jules, an AI coding agent working on the betadvisor-app repository.`,
                ``,
                `## Your Task`,
                `Solve GitHub Issue #${nextIssue.number}: ${nextIssue.title}`,
                ``,
                `## Issue Body`,
                nextBody,
                ``,
                `## Repository Rules`,
                `- Read AGENTS.md at the repo root for ALL coding conventions before writing any code.`,
                `- NEVER throw at module top-level for missing env vars. Use handler-level guards.`,
                `- Your PR body MUST contain "Closes #${nextIssue.number}".`,
                `- Backend CI: cd apps/backend/src && python manage.py check`,
                `- Migration rule: 1 migration maximum per PR. Never generate 2 in the same app.`,
                `- Stripe rule: all Stripe logic in services.py or webhooks.py only, never in views.py.`,
                `- application_fee_percent MUST be 20 (explicit constant, not from settings.PLATFORM_FEE_PERCENT).`,
                ``,
                `## Branch Convention`,
                `Create your working branch from jules/train (the starting branch).`,
                `Branch naming: jules/<issue-number>-<short-slug>`,
              ].join('\n');

              const payload = {
                prompt,
                sourceContext: {
                  source: `sources/github/${owner}/${repo}`,
                  githubRepoContext: {
                    startingBranch: 'jules/train',
                  },
                },
                requirePlanApproval: false,
                automationMode: 'AUTO_CREATE_PR',
              };

              console.log(`[autoqueue] Invoking Jules API for issue #${nextIssue.number}...`);
              const response = await fetch('https://jules.googleapis.com/v1alpha/sessions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Goog-Api-Key': julesApiKey,
                },
                body: JSON.stringify(payload),
              });

              const result = await response.json();
              if (response.ok) {
                console.log(`[autoqueue] ✅ Jules session created: ${result.name}`);
                console.log(`[autoqueue] Jules dispatched on #${nextIssue.number}`);
              } else {
                console.error(`[autoqueue] Jules API error (${response.status}): ${JSON.stringify(result)}`);
              }

              // Une issue débloquée par nuit (cohérent avec règle 1 migration/issue)
              break;
            }
